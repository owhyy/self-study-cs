# TMCS
This is the repository for the [Teach Yourself Computer Science](https://teachyourselfcs.com/) curriculum.

## Contents

### Programming
For the programming part, the curriculum recommends *Brian Harvey's CS 61A* video lectures and the *Structure and Interpretation of Computer Programs* textbook.

The repository for the homeworks, labs and projects can be accessed [here](https://github.com/owhyy/cs61a).

# OSSU
I like using and alternating between different resources for the same (or almost the same) things, so I'm also working through the [OSSU](https://github.com/ossu/computer-science) curriculum.

## Core CS
### How to Code
The repository for some of the work can be accessed [here](https://github.com/owhyy/htdp).
*NOTE: I mainly did the coursera courses, and complimented with the textbook only for the first part, as I had became quite bored when the trees andmutual recursion started to unfold. Now I understand both way better (thanks to SICP).*

This is supposedly a easier SICP. I did this before CS 61A, and can say that there is some overlap, but they are two very different things. *How to Code* covers more of the design process for the procedures. It introduces a blueprint, which will be used pretty much every time you write a procedure or a data definition. I think this is a very nice skill to have, and I have applied it even outside the racket language.

It's not as math-requiring (there were no math-related excersises) so if you know just arithmetic you will be more than fine. At the beginning you learn the blueprint, and use it to write some small games and visual applications. The project of course is a space invaders clone, which you get to write all by yourself. I also recommend doing the book game projects.

The second part was harder. It teaches about mutual recursion, trees and graphs. I could have benefited more from doing book excersises, but I lost interest in the course, so even watching the labs was quite a chore for me. I also ignored the second project altogether.

**TLDR**: no requirements beyond basic arithmetic. Teaches a structured approach to writing procedures and defining data, as well as data structures and recursion. Doing the textbook excersises is highly recommended.


### Programming Languages
The repository for some of the work can be accessed [here](https://github.com/owhyy/programming-languages).
#### Part A
I started doing this course at the same time as I have started CS 61A. It is really intereting to compare the differences and find simmilarities between the two languages, (that is SML and Scheme) as well as see how the simmilar things are accomplished in different ways. Part A was not very hard, and if you did *How to Code* you should be more than good enough to be able to do this one. Actually, if you understand how recursion works, you're probably good enough.

I think that you learn best from actually doing the work, so I liked that it had a lot of problems, and even extra ones. The autograder was also pretty nice. I haven't focused on deadlines, but if you're that kind of person who does, know that you can always reset them. Overall more enjoyable and interesting (imo, of course) than *How to Code*. There is some overlap with the concepts taught in SICP, such as higher order functions, iterators, but there are also a lot of SML specific things like one-of types, type polymorphism (mindblowing), currying and partial application (really cool), type checking and type inference. Not so much overlap with *How to Code*.

Update: I haven't "finished" finished this. I've watched some, but not all the videos from the last week of it, and didn't do the test. I took a break (college started), so when I got back to doing it, I felt I have forgotten most of the stuff. Anyway, SML is interesting. I plan to learn OCaml from the courses recommended by *functionalcs*, so learning it was definitely not a waste of time, and I think I actually made the right decision - starting part B, since it gave me the push to get back on track with my CS61A and programming in general.

#### Part B
#### Part C

If you work really hard, you can finish the entire course in 3 weeks, 1 week for each part.
